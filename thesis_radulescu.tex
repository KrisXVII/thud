%% Le lingue utilizzate, che verranno passate come opzioni al pacchetto babel. Come sempre, l'ultima indicata sar� quella primaria.
%% Se si utilizzano una o pi� lingue diverse da "italian" o "english", leggere le istruzioni in fondo.
\def\thudbabelopt{english,italian}
%% Valori ammessi per target: bach (tesi triennale), mst (tesi magistrale), phd (tesi di dottorato).
%% Valori ammessi per aauheader: '' (vuoto -> nessun header Alpen Adria Univeristat), aics (Department of Artificial Intelligence and Cybersecurity), informatics (Department of Informatics Systems). Il nome del dipartimento � allineato con la versione inglese del logo UniUD.
%% Valori ammessi per style: '' (vuoto -> stile moderno), old (stile tradizionale).
\documentclass[target=bach,aauheader=,style=]{thud}

%% --- Informazioni sulla tesi ---
\course{Informatica}
\title{Implementazione di un sistema di abbonamenti per una piattaforma e-commerce}
\author{Radulescu Cristian}
\supervisor{Prof.\ Vincenzo Riccio}

%% --- Pacchetti consigliati ---
%% pdfx: per generare il PDF/A per l'archiviazione. Necessario solo per la versione finale
\usepackage[a-1b]{pdfx}
%% hyperref: Regola le impostazioni della creazione del PDF... pi� tante altre cose. Ricordarsi di usare l'opzione pdfa.
\usepackage[pdfa]{hyperref}
%% tocbibind: Inserisce nell'indice anche la lista delle figure, la bibliografia, ecc.

%% --- Stili di pagina disponibili (comando \pagestyle) ---
%% sfbig (predefinito): Apertura delle parti e dei capitoli col numero grande; titoli delle parti e dei capitoli e intestazioni di pagina in sans serif.
%% big: Come "sfbig", solo serif.
%% plain: Apertura delle parti e dei capitoli tradizionali di LaTeX; intestazioni di pagina come "big".

\begin{document}
\maketitle

%% Dedica (opzionale)
% \begin{dedication}
% 	Al mio cane,\par per avermi ascoltato mentre ripassavo le lezioni.
% \end{dedication}

%% Ringraziamenti (opzionali)
% \acknowledgements
% Sed vel lorem a arcu faucibus aliquet eu semper tortor. Aliquam dolor lacus, semper vitae ligula sed, blandit iaculis leo. Nam pharetra lobortis leo nec auctor. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Fusce ac risus pulvinar, congue eros non, interdum metus. Mauris tincidunt neque et aliquam imperdiet. Aenean ac tellus id nibh pellentesque pulvinar ut eu lacus. Proin tempor facilisis tortor, et hendrerit purus commodo laoreet. Quisque sed augue id ligula consectetur adipiscing. Vestibulum libero metus, lacinia ac vestibulum eu, varius non arcu. Nam et gravida velit.

%% Sommario (opzionale)
\abstract
Nunc ac dignissim ipsum, quis pulvinar elit. Mauris congue nec leo ornare lobortis. Nulla hendrerit pretium diam nec lobortis. Nullam aliquam laoreet nisl, sit amet facilisis lectus accumsan ut. Duis et elit hendrerit metus venenatis condimentum. Integer id eros molestie, interdum leo sit amet, aliquet metus. Integer fermentum tristique magna, vel luctus neque rhoncus vel. Ut hendrerit et quam et semper. Mauris egestas, odio sed aliquet luctus, magna orci euismod odio, vitae lacinia tellus tellus non lectus. Aliquam urna neque, porta et mattis aliquam, congue sit amet lorem. In ultrices augue sit amet ante vehicula, vitae rhoncus turpis auctor. Donec porta scelerisque eros, at mollis enim imperdiet ut. 

%% Indice
\tableofcontents

%% Lista delle tabelle (se presenti)
%\listoftables

%% Lista delle figure (se presenti)
%\listoffigures

%% Corpo principale del documento
\mainmatter

%% Parte
%% La suddivisione in parti � opzionale; solitamente sono sufficienti i capitoli.
% \part{Parte}

%% Capitolo
\chapter{Introduzione}

introduzione (da scrivere alla fine con contesto, requisiti principali ossia perché stiamo facendo questo software o
stiamo aggiungendo funzionalità, valutazione, conclusioni). Poi elenco contributi per ogni capitolo:
in capitolo 2..., in capitolo 3...

%% Sezione
\section{Titolo della Sezione}
Donec pulvinar neque non lectus vulputate pellentesque. Quisque rutrum arcu velit, in feugiat sapien posuere vel.

%% Sottosezione
\subsection{Sottosezione}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam auctor odio sit amet tempor consequat.

\chapter{Background Aziendale}

In questo capitolo verranno esposte le modalità operative adottate in azienda per lo sviluppo della funzionalità discussa.
\section{Processi Software}
Nell'ambito dello sviluppo software è importante adottare un approccio ingegneristico e strutturato al fine di sviluppare software di
qualità riducendo i costi e i tempi di sviluppo. Convenire in primis il modello di processo software su cui incentrare lo
sviluppo diventa cruciale. Le alternative principali si dividono fra modelli plan-driven e modelli Agile.\\
Il modello plan-driven si caratterizza per:
\begin{itemize}
    \item una sequenza rigida e ben definita di fasi;
    \item una specifica fortmente strutturata dei requisiti;
    \item ampia produzione di documentazione del software.
\end{itemize}
Passando alla fase successiva a quella attuale tutto ciò che è stato svolto in quest'ultima viene bloccato una volta confermato
e non si può più tornare indietro perchè eventuali variazioni nei requisti durante lo sviluppo potrebbero essere troppo costosi
da sviluppare.\\ Il modello Agile invece punta su flessibilità e adattabilità permettendo di:
\begin{itemize}
    \item dare una risposta immediata ai cambiamenti nei requisiti;
    \item coinvolgere il cliente nell'attività di sviluppo;
    \item documentare l'essenziale in modo da concentrarsi sulla scrittura di codice funzionante.
\end{itemize}
L'azienda adotta una variazione del modello agile per cui nei paragrafi seguenti verrà approfondito tale approccio,
con particolare attenzione alle sue implementazioni concrete quali la gestione dei task, i meeting ricorrenti e i strumenti
di supporto.
\section{Lo sviluppo Agile}
Verso la fine degli anni Sessanta, periodo che segnò gli albori dell'Ingegneria del Software, le aziende adottavano esclusivamente il Waterfall Model,
un modello plan-driven a fasi ben definite che impiegava tante risorse: team di grandi dimensioni e tante finanze ma soprattutto tanto tempo
poichè era necessario pianificare accuratamente ogni fase e documentare nei minimi particolari l'intero progetto. Se verso le fasi finali dello
sviluppo si sarebbero riscontrati errori o inconsistenze derivate dalle fasi iniziali, dalla definizione dei requisiti per esempio, aggiustare i
problemi sarebbe stata un'operazione molto complicata.
\par Studi come il \textit{CHAOS Report}\cite{standish1994chaos} dello Standish Group (1994) rilevavano un tasso di fallimento del 30\% dei software
sviluppati in questo modo che spesso venivano cancellati ancora prima di essere conclusi anche a causa dell'incapacità di adeguarsi ai cambiamenti.
Inoltre i costi di sviluppo finali non coincidevano mai con i numeri previsti inizialmente con una media di incremento finale del 189\%.
Anche i tempi complessivi di sviluppo non rispettavano mai quelli aspettati dall'inizio dei lavori, con un incremento del 400\% dato anche dal
fatto che ogni 100 progetti 94 di essi ricominciavano da capo anche più di una volta.
Altre volte succedeva che il prodotto finale non rispettava del tutto le richieste del cliente o risultava incompleto.
\par Di conseguenza, verso la fine degli anni '90 alcune aziende si sono accorte del fatto che il modello plan-driven non si adattava alle esigenze di sviluppo di un
mercato che stava andando a richiedere sempre più prodotti di qualità in tempi sempre più ridotti.
Emerse allora un nuovo metodo di sviluppo software chiamato "eXtreme Programming" che promuoveva un approccio più dinamico allo sviluppo introducendo i seguenti concetti:
\begin{itemize}
    \item storie utente: scenari scritti in linguaggio naturale su schede che descrivono situazioni in cui l'utente potrebbe trovarsi.
    Sono risultate particolarmente utili perchè permettevano di descrivere velocemente i requisiti e potevano cambiare con essi;
    \item refactoring: consiste in un continuo miglioramento del codice mirato a semplificare implementazioni future e a mitigare
    il progressivo deterioramento di esso. Se il codice è semplice e di alta qualità è più auto-esplicativo e potenzialmente tutto il
    team ne può trarre vantaggi;
    \item test: si cominciò a parlare di sviluppo test driven che consisteva nello scrivere prima un test che chiarisse le aspettative
    della prossima implementazione e poi scrivere il codice necessario a soddisfare i test. Il vantaggio principale è che i test possono
    essere automatizzati e definiscono anche una sorta di specifica comportamentale della funzionalità da implementare riducendo i tempi
    di sviluppo;
    \item pair programming: due sviluppatori davanti alla stessa macchina che sviluppano la stessa funzionalità permettendo un confronto
    continuo di idee riducendo i momenti di incertezza o stallo in cui uno sviluppatore singolo potrebbe trovarsi.
\end{itemize}
\par eXtreme Programming non venne mai applicato esattamente come venne concepito, ma i suoi concetti ispirarono profondamente il modello di sviluppo Agile del software.
Nato nei primi anni 2000 dalle necessità dei team di sviluppo di poter reagire in modo più efficiente a requisiti instabili e variabili, tipici di progetti dinamici,
la sua descrizione accurata è stata esposta nel \textit{Manifesto Agile}\cite{beck2001agile} pubblicato nel 2001 i cui
autori sono un gruppo di sviluppatori che avevano riscontrato la necessità di uscire dallo schema plan-driven ritenendolo estremamente rigido.\\
Nel Manifesto sono stati formalizzati i quattro valori fondamentali dell'Agile:
\begin{itemize}
    \item individui e interazioni anziché processi e strumenti: viene attribuita grande importanza alla comunicazione all'interno del
    team di sviluppo e a quella con il cliente poichè nei momenti di difficoltà è proprio la comunicazione fluida e completa fra individui
    a risolvere le incertezze e ciò favorisce una risposta rapida ai cambiamenti e una visione più chiara di ciò che bisogna fare;
    \item software funzionante anziché documentazione completa: il tempo che viene risparmiato redigendo solo la documentazione strettamente
    necessaria viene investito nella produzione di nuovo codice o nel miglioramento del codice già esistente, in questo modo si alza
    la qualità generale del software;
    \item collaborazione col cliente anziché negoziazione di contratti: al contrario dei modelli plan-driven che coinvolgevano il cliente
    solo nella fasi iniziali di negoziazione e definizione dei requisiti, nell'Agile il coinvolgimento si protrae fino alla fine dello sviluppo
    del software offrendo riscontri sulle versioni intermedie al team che saprà come soddifare al meglio le sue esigenze;
    \item capacità di rispondere al cambiamento anziché conformità a un piano: nella visione Agile il cambiamento è un valore aggiunto al
    prodotto. Saper rispondere prontamente ad esso è più importante di formulare un piano d'azione che potrebbe richiedere troppo tempo.
\end{itemize}
Principi dell'Agile in poche parole.

\section{La scelta dell'azienda}


\chapter{Background Software e Ambiente Operativo}

background software e dell'ambiente operativo (linguaggi, librerie)

\chapter{Funzionalità Sviluppata}

Sistema o funzionalità sviluppata: casi d'uso, deployment diagram, comportamentale tipo activity

\chapter{Valutazione}

Valutazione con testing in RSpec (https://github.com/simplecov-ruby/simplecov), questionario sul software per valutare
la bontà del prodotto e la soddisfazione degli utenti (va bene anche il team sviluppatori) -> da fare ad es su google forms o
microsoft forms con likert e domanda aperta per raccogliere feedback

\chapter{Conclusioni e Sviluppi Futuri}

conclusioni e sviluppi futuri


%% Fine dei capitoli normali, inizio dei capitoli-appendice (opzionali)
\appendix

%\part{Appendici}

% \chapter{Titolo della prima appendice}
% Sed purus libero, vestibulum ut nibh vitae, mollis ultricies augue. Pellentesque velit libero, tempor sed pulvinar non, fermentum eu leo. Duis posuere eleifend nulla eget sagittis. Nam laoreet accumsan rutrum. Interdum et malesuada fames ac ante ipsum primis in faucibus. Curabitur eget libero quis leo porttitor vehicula eget nec odio. Proin euismod interdum ligula non ultricies. Maecenas sit amet accumsan sapien.

%% Parte conclusiva del documento; tipicamente per riassunto, bibliografia e/o indice analitico.
\backmatter

%% Riassunto (opzionale)
%\summary
%Maecenas tempor elit sed arcu commodo, dapibus sagittis leo egestas. Praesent at ultrices urna. Integer et nibh in augue mollis facilisis sit amet eget magna. Fusce at porttitor sapien. Phasellus imperdiet, felis et molestie vulputate, mauris sapien tincidunt justo, in lacinia velit nisi nec ipsum. Duis elementum pharetra lorem, ut pellentesque nulla congue et. Sed eu venenatis tellus, pharetra cursus felis. Sed et luctus nunc. Aenean commodo, neque a aliquam bibendum, mauris augue fringilla justo, et scelerisque odio mi sit amet diam. Nulla at placerat nibh, nec rutrum urna. Donec ut egestas magna. Aliquam erat volutpat. Phasellus vestibulum justo sed purus mattis, vitae lacinia magna viverra. Nulla rutrum diam dui, vel semper mi mattis ac. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Donec id vestibulum lectus, eget tristique est.

%% Bibliografia (praticamente obbligatoria)
\bibliographystyle{plain_\languagename}%% Carica l'omonimo file .bst, dove \languagename � la lingua attiva.
%% Nel caso in cui si usi un file .bib (consigliato)
\bibliography{thud}
%% Nel caso di bibliografia manuale, usare l'environment thebibliography.

%% Per l'indice analitico, usare il pacchetto makeidx (o analogo).

\end{document}
